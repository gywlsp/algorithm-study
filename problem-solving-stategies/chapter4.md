# 4 알고리즘 분석

## 개관

주어진 문제를 해결하는 한 가지 방법을 명료하게 써놓은 것을 **알고리즘**이라고 한다.

알고리즘은 문제를 해결하는 방법 그 자체이다. 

알고리즘을 평가하는 두 가지 큰 기준은 알고리즘이 사용하는 **시간과 공간**이다.

# 알고리즘의 시간 복잡도 분석

## 도입

알고리즘의 수행 시간을 어떤 기준으로 측정해야 할까?

### 반복문이 지배한다

대개 알고리즘은 입력 크기에 따라 수행 횟수가 정해지는 반복문이 있다.

입력 크기가 커지면 커질수록 반복문이 알고리즘의 수행 시간을 지배하게 된다.

## 선형 시간 알고리즘

입력 크기에 대해 걸리는 시간을 그래프로 그려봤을 때 정확히 직선이 되는 알고리즘을 선형 시간 알고리즘이라고 부른다.

## 선형 이하 시간 알고리즘

입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이하 시간 알고리즘이라고 부른다. 

ex) 이진탐색

## 지수 시간 알고리즘

### 다항 시간 알고리즘

반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라고 부른다.

### 지수 시간 알고리즘

N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들을 지수 시간에 동작한다고 말한다.

다항 시간 알고리즘이 있는 문제는 계산적으로 쉬운 문제, 아직 없는 문제는 계산적으로 어려운 문제라고 얘기한다.

### 소인수 분해의 수행 시간

입력으로 주어지는 숫자의 개수가 아니라 그 크기에 따라 수행 시간이 달라지는 알고리즘들 또한 지수 수행 시간을 가질 수 있다. 

## 시간 복잡도

시간 복잡도란 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.

기본 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산이다. 반복문을 포함하는 연산은 기본적인 연산이 아니다.

가장 깊이 중첩된 반복문의 수행 횟수는 시간 복잡도의 대략적인 기준이 된다.

### 입력의 종류에 따른 수행 시간의 변화

입력의 종류에 따라 수행 시간이 달라지는 경우를 고려하기 위해 우리는 최선/최악의 경우, 그리고 평균적인 경우에 대한 수행 시간을 각각 따로 계산한다.

최악의 수행시간이 대개 기준으로 많이 사용된다.

### 점근적 시간 표기 : O 표기

**대문자 O 표기법**은 시간복잡도를 더욱 간단하게 표현한 것으로, 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법이다.

가장 깊이 중첩된 반복문의 수행 횟수를 계산했던 것은 수행 시간의 O 표기를 계산한 것이다.

### O 표기법의 의미

O 표기법은 대략적으로 함수의 상한을 나타낸다는 데에 그 의미가 있다.

### 시간 복잡도의 분할 상환 분석

가끔은 문제의 조건에 따라 그보다 더 정확한 시간 복잡도를 분할 상환 분석을 통해 계산하는 것도 가능하다.

N개의 작업에 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우, 각 작업에 걸리는 평균 시간은 전체 시간을 작업의 개수로 나눈 것과 같다.

분할 상환 분석을 이용하면 일반적으로는 시간이 오래 걸려 실행하지 못할 것이라고 여겼던 작업이 시간 안에 돌아가는 것을 이해할 수 있게 된다.

## 수행 시간 어림짐작하기

### 주먹구구 법칙

입력한 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억을 넘어가면 시간 제한을 초과할 가능성이 있다. 

## 계산 복잡도 클래스 : P, NP, NP-완비

계산 복잡도 이론이란 각 문제에 대해 이를 해결하는 얼마나 빠른 알고리즘이 존재하는지를 기준으로 문제를 분류하고, 각 분류의 특성을 연구하는 학문이다.

### 문제의 특성 공부하기

계산 복잡도 이론에서 문제의 난이도는 '해당 문제를 해결하는 빠른 알고리즘이 있느냐'를 나타낸다. 

일반적으로 다항 시간 알고리즘이나 그보다 빠른 알고리즘들만을 '빠르다'고 말한다.

다항 시간 알고리즘이 존재하는 문제들의 집합을 **P 문제**라고 부른다.

### 난이도의 함정

어떤 문제를 다항 시간 안에 풀 수 있음을 증명하기란 쉽지만, 풀 수 없음을 보이기란 어렵다. 따라서 다항 시간 알고리즘이 존재하는 문제와 존재하지 않는 문로 문제들을 구분하기란 어렵다.

계산 복잡도에서 흔히 말하는 '어려운 문제'들은 다음과 같이 정의된다.

- 정말 어려운 문제를 잘 골라서 이것을 어려운 문제의 기준으로 삼는다.
- 기준 문제만큼 어렵거나 그보다 어려운 문제들, 다시 말해 '기준 이상으로 어려운 문제들'만을 어렵다고 부른다.

그러나 우리가 현재 알고 있는 가장 빠른 알고리즘이 꼭 가장 빠른 알고리즘이라는 법은 없다.

계산 복잡도 이론에서는 두 문제의 난이도를 비교하기 위해 **환산**이라는 기법을 이용한다.

환산이란 한 문제를 다른 문제로 바꿔서 푸는 기법이다.

환산 기법을 이용해 주어진 배열을 비교 정렬하는 문제와 최소치를 찾는 문제의 난이도를 비교해보면, 

주어진 배열을 다항 시간에 정렬하고 첫 번째 값을 취하면 최소치를 쉽게 얻을 수 있다. 따라서 최소치를 구하는 데 걸리는 시간이 정렬보다 오래 걸릴 수는 없다. 그래서 정렬 문제는 최소치 문제 이상으로 어렵다. 

### NP 문제, NP 난해 문제

SAT 문제 가 어려운 문제의 기준이 된다. SAT 문제란 N개의 불린 값 변수로 구성된 논리식을 참으로 만드는 변수 값들의 조합을 찾는 문제이다.

SAT 문제는 모든 NP 문제 이상으로 어렵다는 중요한 의미가 있다.

**NP문제**란 답이 주어졌을 때 이것이 정답인지 다항 시간 내에 확인할 수 있는 문제를 말한다. (cf : 다항 시간 알고리즘이 존재하는 문제들의 집합을 **P 문제**라고 부른다.)

부분 집합의 합 문제는 NP 문제이다. 부분 집합 합 문제의 답이 주어졌을 때 이것이 원래 집합의 부분 집합인지, 그리고 원소들의 합이 S인지 다항 시간에 쉽게 확인할 수 있기 때문이다.

**NP-완전**은 다음 두 가지의 조건을 만족하는 결정 문제 C의 집합이다.

1. C가 NP에 속한다.
2. NP에 속하는 모든 문제를 다항 시간 안에 C로 변환할 수 있다. 즉, 다항 시간 환산을 할 수 있다. = **NP-난해**

NP 문제이면서 NP-난해 문제를 NP-완전 문제라고 한다.

또한 위 정의에서 알 수 있듯이, NP-완전인 C(ex: SAT 문제)를 다항시간 안에 풀 수 있다면 모든 NP-완전 문제를 다항시간 안에 풀 수 있다.

다항식 시간 안에 구할 수 없는 문제들을 다른 다항 시간 안에 풀 수 있는 다른 문제로 환원해서 푸는 문제들을 특별하게 **NP-난해 문제**라고 한다. 다항식 시간 안에 도저히 풀 수 없기에 난해라는 이름을 붙였고, 이런 문제들을 위처럼 추측과 검증 과정을 통해서만 결정 해를 구할 수 있다.

### P=NP?

수학 난제로 유명한 P=NP 문제는 P와 NP가 같은지를 확인하는 문제이다. (NP-완전 문제가 P문제가 맞느냐 아니냐'를 증명)

- NP 난해 문제 중 하나를 다항 시간에 풀 수 있다면, 이 알고리즘을 이용해 NP에 속한 모든 문제를 다항 시간에 풀 수 있다. 이 경우 NP에 속한 모든 문제를 다항 시간에 해결할 수 있으므로 P=NP가 된다.
- NP 문제 중 하나를 골라 P에 포함되어 있지 않음을, 다시 말해 다항 시간에 푸는 방법이 없음을 증명하면 P≠NP임을 보일 수 있다.

그러나 P=NP는 미해결된 난제로 위 두 경우 중 하나라도 증명에 성공한 사람이 아무도 없다.

NP 난해 문제는 효율적으로 풀려고 발버둥 치는 대신 모델링을 달리 하거나, 근사해를 찾는 등 다른 방향으로 돌아가는 길을 모색하는 것이 합리적일 것이다. 

## 더 읽을거리

재귀적인 알고리즘의 시간 복잡도를 계산하는 쉬운 방법으로 **마스터 정리**라는 것이 있다.

마스터 정리는 어떤 함수의 수행 시간이 특정 형태의 함수로 표현될 때 이 함수의 O 표기법을 쉽게 계산할 수 있도록 돕는다.

이 정리는 복잡한 분할 정복 알고리즘이 시간 안에 동작할지 의문일 때 종종 도움이 되기도 한다.